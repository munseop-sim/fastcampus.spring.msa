## chapter1. MSA 전환이 필요한 상황 진단하기
1. 전환의 필요성 측면에서 판단
- Business Capabilitiies 고려
- 유지보수의 어려움
- 운영의 어려움
2. 전환의 가능여부 판단
- 조직의 MSA 아키텍처에 대한 이해 필요
- 인프라 지식 필요
- 최고책임자의 MSA전환에 대한 충분한 필요성 `제일 중요`
3. MSA로의 전환은 항상 옳지만은 않다. 
- 조직이 처한 상황, 조직구성원들의 상태 등에 따라 때로는 모놀리식이 조직운영에 나을 수도 있다.

## chapter2. 패턴
1. 분해패턴 : 어떤 판단기준에 따라 서비스를 분리할 것인지에 대한 패턴
- 비즈니스 능력에 따른 분해
    - 장점 
        - 대규모 조직에 적합
        - 비즈니스 특성으로 인해 내부 서비스간 통신이 빈번한 경우
    - 단점
        - 서비스간 응집도, 결합도, 종속성 증가
        - 콘웨이의 법칙처럼 서비스별 팀의 구조가 희석될 가능성 존재
- 하위도메인 패턴별 분해(DDD)
    - 장점
        - 서비스간 독립성, 격리성 증가 / 결합도 감소
        - 서비스간 종속성 최소화, 서비스간 영향도 감소
        - 장애영향 최소화
    - 단점
        - 서비스간 불필요한 통신가능성 성능이슈
        - 지나치게 많은 서비스로 분리될 가능성 존재
        - 대규모 시스템에서는 비효율성이 크게 증가될 가능성
2. 통신패턴 : 각 모듈간의 통신문제를 해결하기 위한 패턴
    - Sync(동기) 패턴
    - Async(비동기) 패턴
3. 트랜잭션 패턴 (`구현 및 관리가 제일 어려움`)
    - 2PC(2 Phase Commit)
    - Compensating Transactions(보상 트랜잭션)
    - Saga Pattern
4. 데이터 쿼리 패턴
    - API Aggregation패턴
    - CQRS 패턴
5. 가시성(Visibility, Observability) - 어느정도 표준이 존재
    - 로깅, 메트릭의 중앙집중 및 필터링등을 통한 한곳에서의 모니텅
6. 신뢰성(Reliablility)
    - 분리/분해로 인해 떨어진 신뢰성을 해결하기 위한 패턴
    - 장애복구, 자가치유, 무정지배포(Graceful Shutdown)..
    - 서킷브레이커(Circuit Breaker) : 다른 서비스를 호출할 때 장애가 발생하면 요청을 차단하고, 대체응답을 보내는 패턴
7. 테스트패턴
8. 외부 API패턴
9. 디스커버리 패턴


## chapter1,chapter2 결론
모놀리식 환경에서는 쉽게 구현되던 것들이(트랜잭션 등) MSA환경에서는 굉장히 어렵게 구현될 수 있다.
즉, MSA에 대한 사전지식(트랜잭션관리, 신뢰성 관리, 비즈니스 분해 법 등..)이 충분하지 않은 상태에서 유행따라 MSA구현하려 한다면 재앙이 될 수도 있다.

## chapter3. 소프트웨어 아키텍처
- 아키텍처가 중요한 이유
    - MSA는 모놀리식에서 분리/분해된 MS(Micro Service)들의 모음이다. MS를 이루는 비즈니스/도메인은 경우에 따라 혹은 시간이 지남에 따라 복잡도가 증가하기 마련이다. 그리고 개별적인 MS내에서도 비즈니스적인 목적에 따라 별개의 기능, 효율을 중요시 해야하는 상황이 발생할 수 있다.
    - MS를 이루는 SW에 따라 각 서비스의 BusinessCapability의 변화가 필요하다.
- MSA(Mirco Service Architecture)는 광의 SW 아키텍처 -> 유연성, 확장성, 낮은 응집도/결합도 등 MSA의 특성이 각 Mirco Service안에서도 필요하다.
    - MSA는 느슨하게 결합된 서비스의 집합
- 대표적인 SW아키텍처
    - 계층화 아키텍처(Layered Architecture) : 여러개의 계층으로 나누어 각 계층에서 하는 일을 한정시켜 각 계층별로 독립적으로 개발/배포/확장이 가능
    - 헥사고날 아키텍처(Hexagonal Architecture) : 각 계층에서 하던 일을 '내부'와 '외부'라느는 개념으로 나누어 각각에 맞는 별도의 인터페이스를 정의하고 '내부'의 로직은 '외부'의 인터페이스를 통해서만 접근이 가능하다.

## chapter4. LAYERED ARCHITECTURE
- 모놀리스 구조와 계층별로 구분된 일반적인 프로젝트 조직구조에 최적화
- Presentation Layer, Application Layer(Bussiness Logic), Persistence Layer(1 DB Endpoint)등으로 이루어져 있으며, 각 레이어는 하위계층으로의 의존성이 존재한다. 그러나 접근은 상위계층으로도 가능한 상황들이 발생한다. 즉 구현에 대한 로직의존성은 단방향이지만, 접근은 양방향으로 가능하다.
- 1DB로 인한 각 계층의 역할, 목적과 계층간의 의존성 구분이 희미해짐 : 설계상의 역 디펜던시 발생

## chapter5. HEXAGONAL ARCHITECTURE
- 내부 = 포트 : 각 서비스에서 비즈니스 로직에 맞게 정의된 인터페이스
    - 비즈니스 로직 입장에서 어댑터와 통신하기 위한 동작을 정의한 `인터페이스`
    - 내부 비즈니스 로직과 인터페이스를 분리하여 내부로직의 구현은 인터페이스와 무관하게 개발가능하다.
- 외부 = 어댑터 : 모든 외부시스템과의 직접적인 상호작용 
    - 서비스입장에서 이서비스가 사용하는 외부시스템과의 직접적인 구현 및 상호작용 처리
    - Adapter를 통해 외부서비스와의 의존성을 분리하여 언제든 쉽게 교체하여 유연하고 확정성있는 대처를 할 수 있다.
- 외부 -> 내부 
    - Request요청등을 말함
    - 인바운드 어댑터 -> 인바운드 포트 -> 비즈니스로직
- 내부 -> 외부
    - DB호출과 같은작업을 일컬음
    - 내부라 함은 비즈니스 로직만 존재
    - 비즈니스로직 -> 아웃바운드 포트 -> 아웃바운드 어댑터
- 레이어드 아키텍처에 비해 작성되는 코드의 양은 많지만 아키텍처 특성상 유연성, 확장성이 그에 비하여 월등히 좋다. 즉 높은 확장성 및 유연성으로 인해 Business Capability를 높일 수 있다.
- 위와 같은 사실로 인해 잘 만들어진 헥사고날 아키텍처는 MSA환경에서 매우 적합한 아키텍처이다.